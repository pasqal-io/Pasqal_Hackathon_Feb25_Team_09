# -*- coding: utf-8 -*-
"""Copia de PM_Simulation_AIN_Two-Three-Body-Coupling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TSeNLmuIwFdYs7H-KiNE1xQkJDbOCN14
"""

import os
os.environ["KMP_DUPLICATE_LIB_OK"]="TRUE"

from pulser import Register, Sequence, Pulse
from pulser.devices import DigitalAnalogDevice
from pulser.waveforms import ConstantWaveform
from pulser_simulation import QutipEmulator
import numpy as np
import time

# Step 1: Define Register with 16 Qubits
positions = {
    "Al1": (0, 0), "N1": (4, 0), "Al2": (0, 6), "N2": (4, 6),
    "Al3": (8, 0), "N3": (12, 0), "Al4": (8, 6), "N4": (12, 6),
    "Al5": (16, 0), "N5": (20, 0), "Al6": (16, 6), "N6": (20, 6),
    "Al7": (24, 0), "N7": (28, 0), "Al8": (24, 6), "N8": (28, 6)
}
register = Register(positions)
print("Register defined with positions:", register.qubits)

# Step 2: Enhanced SW Hamiltonian with Three-Body and Coupling Terms
def compute_two_body(r):
    epsilon = 3.5  # eV
    sigma = 1.9    # Å
    A = 7.049556277
    B = 0.6022245584
    p = 4
    q = 0
    r_cut = 3.5    # Å
    if r <= 0 or r >= r_cut:
        return 0
    term1 = A * epsilon * (B * (sigma/r)**p - (sigma/r)**q)
    term2 = np.exp(1.7 * sigma / (r - r_cut))
    return term1 * term2

def compute_three_body(r_ij, r_ik, cos_theta_jik):
    epsilon = 3.5  # eV
    sigma = 1.9    # Å
    r_cut = 3.5    # Å
    lambda_ = 21.0  # Strength, tuned for tetrahedral stability
    gamma = 1.2    # Decay factor
    theta_0 = np.deg2rad(109.5)  # Equilibrium angle for wurtzite AlN
    if r_ij >= r_cut or r_ik >= r_cut or r_ij <= 0 or r_ik <= 0:
        return 0
    exp_term = np.exp(gamma * sigma / (r_ij - r_cut)) * np.exp(gamma * sigma / (r_ik - r_cut))
    angle_term = (cos_theta_jik - np.cos(theta_0))**2
    return lambda_ * epsilon * angle_term * exp_term

def hamiltonian(register, config):
    qubits = list(register.qubits.items())
    neighbor_pairs = [
        (0, 1), (2, 3), (4, 5), (6, 7), (8, 9), (10, 11), (12, 13), (14, 15),
        (0, 2), (1, 3), (4, 6), (5, 7), (8, 10), (9, 11), (12, 14), (13, 15)
    ]
    # Define triplets (e.g., Al-N-Al) based on wurtzite topology
    triplets = [
        (0, 1, 2), (2, 3, 1), (4, 5, 6), (6, 7, 5),  # Horizontal N-centered
        (8, 9, 10), (10, 11, 9), (12, 13, 14), (14, 15, 13),  # Horizontal N-centered
        (1, 0, 3), (0, 2, 5), (5, 4, 7), (4, 6, 9),  # Vertical Al-centered
        (9, 8, 11), (8, 10, 13), (13, 12, 15), (12, 14, 11)  # Vertical Al-centered
    ]
    scale_factor = 1.9 / 4.0
    g = 0.5  # eV/Å, piezoelectric coupling strength

    # Two-body energy
    two_body_energy = 0
    active_pairs = 0
    for i, j in neighbor_pairs:
        pos_i, pos_j = qubits[i][1], qubits[j][1]
        disp_i = -0.005 if int(config[i]) == 0 else 0.005
        disp_j = -0.005 if int(config[j]) == 0 else 0.005
        r_um = np.linalg.norm(np.array(pos_i) - np.array(pos_j))
        r = r_um * scale_factor + (disp_i - disp_j)
        pair_energy = compute_two_body(r)
        two_body_energy += pair_energy
        if pair_energy != 0:
            active_pairs += 1

    # Three-body energy
    three_body_energy = 0
    for i, j, k in triplets:
        pos_i, pos_j, pos_k = qubits[i][1], qubits[j][1], qubits[k][1]
        disp_i = -0.005 if int(config[i]) == 0 else 0.005
        disp_j = -0.005 if int(config[j]) == 0 else 0.005
        disp_k = -0.005 if int(config[k]) == 0 else 0.005
        r_ij = np.linalg.norm(np.array(pos_i) - np.array(pos_j)) * scale_factor + (disp_i - disp_j)
        r_ik = np.linalg.norm(np.array(pos_i) - np.array(pos_k)) * scale_factor + (disp_i - disp_k)
        r_jk = np.linalg.norm(np.array(pos_j) - np.array(pos_k)) * scale_factor + (disp_j - disp_k)
        # Cosine of angle j-i-k using law of cosines
        cos_theta_jik = (r_ij**2 + r_ik**2 - r_jk**2) / (2 * r_ij * r_ik)
        three_body_energy += compute_three_body(r_ij, r_ik, cos_theta_jik)

    # Piezoelectric coupling energy
    coupling_energy = 0
    for i in range(len(config)):
        x_i = -0.005 if int(config[i]) == 0 else 0.005  # Displacement from config
        sigma_i_z = -1 if int(config[i]) == 0 else 1    # Map 0/1 to -1/+1
        coupling_energy += g * x_i * sigma_i_z

    total_energy = two_body_energy + three_body_energy + coupling_energy
    print(f"Two-body: {two_body_energy:.4f} eV, Three-body: {three_body_energy:.4f} eV, Coupling: {coupling_energy:.4f} eV, Total: {total_energy:.4f} eV, Active pairs: {active_pairs}")
    return total_energy

# Step 3: Optimized VQE Implementation (Unchanged)
def evaluate_energy(params, register):
    seq = Sequence(register, DigitalAnalogDevice)
    seq.declare_channel("rydberg_local", "rydberg_local")
    n_qubits = len(register.qubits)
    for i, qubit_id in enumerate(register.qubits.keys()):
        pulse1 = Pulse(ConstantWaveform(52, params[i]), ConstantWaveform(52, 0), 0)
        pulse2 = Pulse(ConstantWaveform(52, params[i + n_qubits]), ConstantWaveform(52, 0), np.pi/2)
        seq.target(qubit_id, "rydberg_local")
        seq.add(pulse1, "rydberg_local")
        seq.add(pulse2, "rydberg_local")
    sim = QutipEmulator.from_sequence(seq)
    result = sim.run()
    final_state = result.get_final_state()
    raw_probs = np.abs(final_state.full())**2
    probs = raw_probs / np.sum(raw_probs)
    basis_states = [format(i, f'0{n_qubits}b') for i in range(2**n_qubits)]
    samples = np.random.choice(basis_states, size=3, p=probs.flatten())
    sample_dict = {}
    for config in samples:
        sample_dict[config] = sample_dict.get(config, 0) + 1
    total_energy = 0
    total_counts = sum(sample_dict.values())
    for config, count in sample_dict.items():
        config_energy = hamiltonian(register, config)
        total_energy += count * config_energy
    expected_energy = total_energy / total_counts
    return expected_energy

def optimize_vqe(register, max_iter=10):
    n_qubits = len(register.qubits)
    params = np.random.random(2 * n_qubits) * 0.5
    best_energy = float('inf')
    best_params = params.copy()
    start_time = time.time()
    for _ in range(max_iter):
        iter_start = time.time()
        new_params = params + np.random.normal(0, 0.2, 2 * n_qubits)
        new_params = np.clip(new_params, 0, None)
        new_energy = evaluate_energy(new_params, register)
        if new_energy < best_energy:
            best_energy = new_energy
            best_params = new_params
            params = new_params
            params_str = f"[{', '.join(f'{x:.4f}' for x in best_params[:5])}, ...]"
            print(f"Iteration {_+1}, Energy: {new_energy:.4f} eV, Best Params (first 5): {params_str}, Time: {time.time() - iter_start:.2f} seconds")
        else:
            print(f"Iteration {_+1}, Energy: {new_energy:.4f} eV (no improvement), Time: {time.time() - iter_start:.2f} seconds")
    total_time = time.time() - start_time
    print(f"Total simulation time: {total_time:.4f} seconds")
    print(f"Final Best Params: [{', '.join(f'{x:.4f}' for x in best_params)}]")
    return best_params, best_energy

# Simulate Equilibrium State
best_params, ground_energy = optimize_vqe(register)
print(f"Optimized ground state energy: {ground_energy} eV")

# Visualize
print("Equilibrium Atomic Structure:")
register.draw()

print("Equilibrium Pulse Sequence:")
seq_final = Sequence(register, DigitalAnalogDevice)
seq_final.declare_channel("rydberg_local", "rydberg_local")
n_qubits = len(register.qubits)
for i, qubit_id in enumerate(register.qubits.keys()):
    pulse1 = Pulse(ConstantWaveform(52, best_params[i]), ConstantWaveform(52, 0), 0)
    pulse2 = Pulse(ConstantWaveform(52, best_params[i + n_qubits]), ConstantWaveform(52, 0), np.pi/2)
    seq_final.target(qubit_id, "rydberg_local")
    seq_final.add(pulse1, "rydberg_local")
    seq_final.add(pulse2, "rydberg_local")
seq_final.draw(mode="input")